#**************************************************************************************************************************
###Ansible - Demo.

================
##Adhoc Commands:
================

ansible controller
> /etc/ansible  == will have all files in this directory

###test ssh connection from ansible host/controller to remote hosts

ssh -p22 -i /etc/ansible/ansiblenodekeys/ansiblenode1.key ansibleadmin@172.31.1.175
ssh -p22 -i /etc/ansible/ansiblenodekeys/ansiblenode2.key ansibleadmin@172.31.0.194

###update vi etc/ansible/host
#**************************************
#hosts file is the default Inventory file for ansible 
#**************************************

[testnodes]
samplenode1 ansible_ssh_host=172.31.1.175 ansible_ssh_user=ansibleadmin ansible_ssh_private_key_file=/etc/ansible/ansiblenodekeys/ansiblenode1.key
samplenode2 ansible_ssh_host=172.31.0.194 ansible_ssh_user=ansibleadmin ansible_ssh_private_key_file=/etc/ansible/ansiblenodekeys/ansiblenode2.key

#**************************************************************************************************************************
#Access through Ansible Controller :
#**************************************************************************************************************************
Ansible Modules: Eg.: 

setup,copy,fetch,user,command,shell,ping,service,

ansible testnodes -m ping

ansible all -m ping ### will ping all hosts from /etc/ansible/hosts file
ansible -m ping all --works similar

ansible samplenode1 -m ping
ansible samplenode2 -m ping

*******************************************************************

if we have defined inventory file separatly
then
#for using user defined Inventory file

> we can edit conf file to inventory as /etc/ansible/inventory
> then in that case by default inventory file will be picked as source so no need to mention the file name in the adhoc command


> cat cd /etc/ansible/hosts > inventoryfile.txt   -- if file is present in same path else complete path should be mentioned
> we have to define the host file now, like
ansible -i inventoryfile.txt -m ping all

ansible -i inventoryfile.txt -m ping samplenode1
# ansible -i <hostfilename) -m <module name> <any node/all>

#ansible ansible-node1 -m ping -i myinventoryfile.txt

#**************************************************************************************************************************
> to install HTTPD package on sample node1 
> --become is to escalate the privilage and then execute because in inventory file we gavae ansibleadmin as user so it cant install
 ansible]$ ansible -i inventoryfile.txt -m yum -a "name=httpd state=present" samplenode1 --become
 
 samplenode1 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "changed": true,
    "changes": {
        "installed": [
            "httpd"
        ]
    },


===== if we ran command again


samplenode1 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "changed": false,   -- as there is no change it is False
    "msg": "",
    "rc": 0,
    "results": [
        "httpd-2.4.54-1.amzn2.x86_64 providing httpd is already installed"
    ]
}

**********************************************************************************************************************
> IDEMPOTENT -  property of some operations such that no matter how many times you execute them, you achieve the same result.
it means it will work only if there is change else same state
 **********************************************************************************************************************
> to enable the above installed httpd, 

 ansible -i inventoryfile.txt -m service -a "name=httpd state=started enabled=yes" samplenode1 --become

-------- this is causing error need to check.

[WARNING]: Platform linux on host samplenode1 is using the discovered Python interpreter at
/usr/bin/python, but future installation of another Python interpreter could change this. See
https://docs.ansible.com/ansible/2.9/reference_appendices/interpreter_discovery.html for more
information.
samplenode1 | FAILED! => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "changed": false,
    "msg": "Unable to start service httpd: Job for httpd.service failed. See \"systemctl status httpd.service\" and \"journalctl -xe\" for details.\n"



***********************************************************************************************************************
> to deploy a web page index.html from controller to node

ansible -i inventoryfile.txt -m copy -a "src=index.html dest=/var/www/html/index.html" samplenode1 --become


[WARNING]: Platform linux on host samplenode1 is using the discovered Python interpreter at
/usr/bin/python, but future installation of another Python interpreter could change this. See
https://docs.ansible.com/ansible/2.9/reference_appendices/interpreter_discovery.html for more
information.
samplenode1 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "changed": true,
    "checksum": "4bcff6b790c430561af148937a9661c25b17e121",
    "dest": "/var/www/html/index.html",
    "gid": 0,
    "group": "root",
    "md5sum": "d7cbc2f4f5381e39cd4b1e13ee4d05cf",
    "mode": "0644",
    "owner": "root",
    "size": 34,
    "src": "/home/ansibleadmin/.ansible/tmp/ansible-tmp-1667825333.1-5028-261556534765134/source",
    "state": "file",
    "uid": 0
}


> you can check web page in target machine
> enable port 80 - for web access - you can check the file too.

**********************************************************************************************************************

ansible testnodes -m shell -a "sleep 5 ; echo 'hi'"

ANSIBLE_KEEP_REMOTE_FILES=1 ansible samplenode1 -m shell -a "uptime"

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ansible Facts!

ansible samplenode1 -m setup
ansible samplenode2 -m setup -a "filter=ansible_mounts"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

##Transfer a file from Ansible Controller to Nodes using copy Module

ansible samplenode1 -m copy -a "src=/etc/ansible/playbooks/samplefile.txt dest=/home/ansibleadmin"

ansible samplenode1 -m copy -a "src=/etc/ansible/testfile1.txt dest=/home/ansibleadmin backup=yes"


###idempotent

ansible -i inventoryfile.txt samplenode1 -m copy -a "content='Hello from Controller\n' dest=/home/ansibleadmin/hello.txt"
ansible -i <host> <node> -m <module> -a <parameter>  = destination file should exit else it will throw error

# Node we can place anywhere in the command

ansible testnodes -m copy -a "content='hello from Ansible Controller\n' dest=/dest/path/hello.txt"

ansible testnodes -m copy -a "content='hello from Ansible Controller\n' dest=/dest/path/hello.txt backup=yes"    ---> -a is for arguments

ansible testnodes -m copy -a "content='hello from Ansible Controller\n' dest=/dest/path/hello.txt backup=yes"


##Transfer a file from Ansible Nodes to Ansible Controller using fetch Module

ansible testnodes -m fetch -a "src=/home/ansibleadmin/file1.txt dest=/etc/ansible/"     # complete path will be pulled into controller lol not only just file

ansible testnodes -m fetch -a "src=/srcfile/path/nodefile1.txt dest=/dest/path/"


#Adhoc Commands with various Modules
#How Ansible Works?
#Ansible Facts & Variables

#######Adhoc Commands with various Modules

###Test Connection:
ansible testnodes -m ping

### Test Uptime of Nodes:
ansible testnodes -m shell -a "uptime"

### Pass Multiple Groups:
ansible testnodes1:testnodes2 -m shell -a "uptime"

### Check RAM Utilization:
ansible testnodes -m shell -a "free -m"

###Pass Different Inventory File:
ansible -i inventory_file_name prodnodes -m shell -a "uptime"


### List all modules:
ansible-doc -l 
ansible-doc -l | grep <command>

### No. of modules:
ansible-doc -l | wc -l

### Search for specific modules:
ansible-doc -l | grep shel

### To know about any specific modules:
ansible-doc shell  # this gives detailedddd explanation

*********************************************************************************************
[devopsadmin@ip-172-31-47-91 ansible]$ ansible -i inventoryfile.txt -m yum -a "name=httpd state=absent" --become samplenode1
[WARNING]: Platform linux on host samplenode1 is using the discovered Python interpreter at
/usr/bin/python, but future installation of another Python interpreter could change this. See
https://docs.ansible.com/ansible/2.9/reference_appendices/interpreter_discovery.html for more
information.
samplenode1 | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "changed": true,
    "changes": {
        "removed": [
            "httpd"
        ]
    },

**************************************************************************************************************
===========================
====== PLAYBOOK/YAML SYNTAX =========
===========================

Source : https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html

To check the syntax of the playbook file 
Command :
ansible-playbook -i <host file> <yaml file> --syntax-check

============ to check the module syntax and how to use ====================
-- ansible-doc <module_name>
ansible-doc yum

=====================
Documentation about Modules :

https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html

**************************************************************************************************************************

To install httpd in sample node 1
> file name : httpdinstall.yaml

- name: Setup webserver
  hosts: samplenode1
  become: yes
  tasks:
   - name: Installing an httpd server
     yum:
        name: httpd
        state: present

~
 COmmand:
 
ansible-playbook -i inventoryfile.txt httpdinstall.yaml

# we should run the command only in the present directory where playbook is present

=============================================
ansible-playbook -i inventoryfile.txt httpdinstall.yaml C   -- this will run the syntax to check(dummy run), but wont effect target machine



*************************************************************************************************************************
#create a dir in /ect/ansible/ for playbooks
#and create the playbook .yaml files as mentioned below:
#sample playbooks:

#testfile.yaml
---
- hosts: all
  tasks:
  - name: Creating an empty file
    file:
      path: "/home/ansibleadmin/file1.txt"
      state: touch

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#testfile1.yaml
---
- hosts: all
  tasks:
  - name: Creating a file with content
    copy:
      dest: "/home/ansibleadmin/filewithrecs.txt"
#	  src: "file1.txt"
      content: |
        line 01
        line 02
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	

# to remove directory

- hosts: all
  tasks:		
  - name: Recursively remove directory
    file:
      path: /home/dummy
      state: absent

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
---
- name: Provisioning Server 
  hosts: all
  become: yes
  tasks:
    - name: Install NTP on Centos 
      yum:
        name: "{{item}}"
        state: present
      when: ansible_distribution == "CentOS"
      loop:
        - ntp
        - wget
        - git
        - zip
        - unzip

    - name: Install NTP on Ubuntu
      apt:
         name: "{{item}}"
         state: present
         update_cache: yes
      when: ansible_distribution == "Ubuntu"
      loop:
        - ntp
        - wget
        - git
        - zip
        - unzip

    - name: Start & enable NTP on Redhat
      service:
        name: ntpd
        state: started
        enabled: yes
      when: ansible_os_family == "RedHat"

    - name: Start & enable NTP on Debian
      service:
        name: ntp
        state: started
        enabled: yes
      when: ansible_os_family == "Debian"

    - name: Add group
      group:
         name: devops
         state: present

    - name: Add users
      user:
          name: "{{item}}"
          state: present
          groups: devops
      loop: "{{usernames}}"

    - name: Banner file /etc/motd
      copy:
        content: "This {{ansible_distribution}} is Managed by Ansible.\n"
        dest: /etc/motd

    - name: Deploy NTP conf file for RedHat
      template:
         src: templates/ntp_redhat.conf.j2
         dest: /etc/ntp.conf
      when: ansible_os_family == "RedHat"
      notify:
        - Restart NTP on Redhat

    - name: Deploy NTP conf file for Debian
      template:
         src: templates/ntp_debian.conf.j2
         dest: /etc/ntp.conf
      when: ansible_os_family == "Debian"
      notify:
        - Restart NTP on Debian

    - name: Dir for dev data
      file:                                  -- manage files and its properties
        path: /opt/devdata
        state: directory
        mode: 0775

  handlers:     -- running operations on change
    - name: Restart NTP on Redhat
      service:
        name: ntpd
        state: restarted
        enabled: yes
      when: ansible_os_family == "RedHat"

    - name: Restart NTP on Debian
      service:
         name: ntp
         state: restarted
         enabled: yes
      when: ansible_os_family == "Debian"




#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#Ansible VAriables !
#shell : echo $var1 

#debugmod.yaml

---
 - hosts: samplenode1
   tasks:
   - debug:  
      msg:
       - "The os distribution is: {{ansible_distribution}}" 
       - "THe os name is: {{ansible_system}}"
       - "The os family is: {{ansible_os_family}}"
       - "THe mount points are :{{ansible_mounts}}"
   
   
 ansible-playbook -i /etc/ansible/inventoryfile.txt debug.yaml   
       
# How to jus verify playbook syntax:
ansible-playbook testfile.yaml --syntax-check

========================================

ansible-playbook -i /etc/ansible/inventoryfile.txt debug.yaml

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~ test_var-datatype.yaml
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#test_var-datatype.yaml
---
 - hosts: samplenode1
   vars:
    x: 23
    my_num: 45.67
    my_name: Loksai
    my_b: YES   
   tasks:
   - debug:    -- debug is for printing
      msg:
       - "The value of x is: {{x}} and type: {{x|type_debug}}"  --jinja 2 templating
       - "THe value of my_num: {{my_num}} and type : {{my_num|type_debug}}"
       - "The value of my_name : {{my_name}} and type: {{my_name|type_debug}}"
       - "THe value of my_b is: {{my_b}} and type : {{my_b|type_debug}}"


# is for comment in yaml
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~ register and set-facts
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#test_var-datatype.yaml
---
 - hosts: testnodes
   gather_facts: false
   tasks:
   - shell: "bash --version"

#test_var-datatype.yaml
---
 - hosts: samplenode1
   tasks:
   - shell: "bash --version"
     register: bash_ver
   - debug: var=bash_version
   
   
#register_set_facts.yaml
---
 - hosts: samplenode1
   tasks:
   - shell: "bash --version"
     register: bash_ver
   - set_fact:
      bash_version: "{{bash_ver.stdout.split('\n')[0].split()[3]}}"
      my_value: "bash version"
   - debug: var=bash_version
   
   
Become :

---
  - hosts: samplenode1
    gather_facts: false
    #become: yes
    tasks:
      - name: Install httpd
        yum:
          name: httpd
          state: latest 

## state ::::  present | absent | latest 
	       to install | to uninstall | to update

==============================================================================================================================
> task which needs to be executed only when previous task executed/ based on previous task result 

Handlers :

---
  - hosts: samplenode1
    #gather_facts: false
    become: yes
    tasks:
      - name: Install httpd
        yum:
          name: httpd
          state: present
		register: resultt
      - debug: var=resultt.changed		
      - name: start httpd
        service:
          name: httpd
          state: started
		when: resultt.changed == True

  - hosts: samplenode1
    #gather_facts: false
    become: yes
    tasks:
      - name: Install httpd
        yum:
          name: httpd
          state: present
		register: resultt
      - debug: var=resultt.changed		
      - name: start httpd
        service:
          name: httpd
          state: started
		when: resultt.changed == True
		
---
  - hosts: samplenode1
    gather_facts: false
    become: yes
    tasks:
      - name: Install httpd
        yum:
          name: httpd
          state: present
    notify:
      - start httpd     --- handler name
    handlers:
    - name: start httpd         -- "Start httpd" handler block
      service:
          name: httpd
          state: started
		  
---
  - hosts: samplenode1
    become: yes
    tasks:
      - name: Install httpd
        yum:
          name: httpd
          state: present			# CHANGE=0		
      - name: start httpd
        service:
          name: httpd
          name: httpd
          state: started			# CHANGE=0

state ::: started | stopped | reester

---
  - hosts: samplenode1
    gather_facts: false
    become: yes
    tasks:
      - name: Install httpd
        yum:
          name: httpd
          state: present
    notify:
      - start httpd2
    handlers:
    - name: start httpd1
      service:
          name: httpd
          state: started
		  
#Eg.: Labels & Selectors :::  




Loops :

---
  - hosts: samplenode1
    become: yes
    tasks:
      - yum:
         name: git
         state: present
      - yum:
         name: httpd
         state: present
      - yum:
         name: vim
         state: present

---
  - hosts: samplenode1
    gather_facts: false
    become: yes
    tasks:
      - yum:
         name: "{{item}}"
         state: absent
        loop:
          - git
          - httpd
          - vim
          
   
#~~~~~~~~~~~~~~~~~~~~~~~~~
file_name : var_precedence.yaml

- name: Understanding precedence of variables
  hosts: all
  become: yes
  gather_facts: False
  vars:
    USRNM: playuser
    COMM: variable from playbook
  tasks:
    - name: create a user
      user:
        name: "{{USRNM}}"
        comment: "{{COMM}}"
      register: USROUT

    - debug:
        var: USROUT.name

    - debug:
        var: USROUT.comment

ansible-playbook -i  /etc/ansible/inventoryfile.txt var_precedence.yaml


Precedence of Variables: 

Playbook => host_vars/hostname => group_vars/grpname => all

Website : https://docs.ansible.com/ansible/latest/reference_appendices/general_precedence.html

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fact Variables : Setup Module

Ansible Facts!

ansible samplenode1 -m setup
ansible samplenode2 -m setup -a "filter=ansible_mounts"

I belive , when we are mentioning host file in syntax (adhoc) we should give -i 




---
- name: Learning fact variables
  hosts: all
  tasks:
    - name: Print OS names
      debug:
        var: ansible_distribution

    - name: Print Memory details
      debug:
        var: ansible_memory_mb

    - name: Print Real Memory details
      debug:
        var: ansible_memory_mb.real.free    -- since its memory in setup is dictionary so we are fetching proper need value.

    - name: Print Processor name
      debug:
        var: ansible_processor[2]       -- processor is list so [] is used to fetch required value with index

ansible-playbook -i /etc/ansible/inventoryfile.txt facts.yaml


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Decision Making : loops

website : https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html

---
- name: Provisioning Server 
  hosts: all
  become: yes
  tasks:
    - name: Install NTP on Centos 
      yum:
        name: "{{item}}"
        state: present
      when: ansible_distribution == "CentOS"
      loop:
        - ntp
        - wget
        - git
        - zip
        - unzip

    - name: Install NTP on Ubuntu
      apt:
         name: "{{item}}"
         state: present
         update_cache: yes
      when: ansible_distribution == "Ubuntu"
      loop:
        - ntp
        - wget
        - git
        - zip
        - unzip

    - name: Start & enable NTP on Redhat
      service:
        name: ntpd
        state: started
        enabled: yes
      when: ansible_os_family == "RedHat"

    - name: Start & enable NTP on Debian
      service:
        name: ntp
        state: started
        enabled: yes
      when: ansible_os_family == "Debian"

    - name: Add group
      group:
         name: devops
         state: present

    - name: Add users
      user:
          name: "{{item}}"
          state: present
          groups: devops
      loop: "{{usernames}}"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ansible Roles

Intranet: Repositories for Managing the Playbooks 
Ansible Playbooks --- > Repository
Internet : Access the playbooks 

Ansible-galaxy : 
ansibl-galaxy init <role_name>
link: https://galaxy.ansible.com/

Roles! are the packages of Ansible components / Templates



Roles 
organise and reuse
> like comman logic , we call it multiple times using function call thats the logix here
> we declare task , then we call using role
this is used to manage playbook task and ansible components

Like declaring a task in one file 
intalling and configuring mysql db


then we can create an another file with Role keyword calling above file
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Visual Block Mode

First, move the cursor to the first char of the first line in block code you want to comment, then type:

Ctrl + v                                    

then vim will go into VISUAL BLOCK mode. Use j to move the cursor down until you reach the last line of your code block. Then type:

Shift + i

now vim goes to INSERT mode and the cursor is at the first char of the first line. Finally, type # then ESC and the code block is now commented.

To decomment, do the same things but instead of type Shift + I, you just type x to remove all # after highlight them in VISUAL BLOCK mode.

++++++++++++++++++++++++++++++++++++++++++++++

:%d -> to delete vi content


