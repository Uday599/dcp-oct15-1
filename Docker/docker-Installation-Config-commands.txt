VM -> will have os -> hypervisor -> each differecnt os -> application

Containers 

we dont have different OS's here , only underlying main OS will be used to run application 
Here we have entity called 'Docker' like hypervisor in VMs

*  Container runtime environment -> docker

each service in docker will have its own tree directory structure , hence making sure that it is isolated from other servcies

Hypervisor is for physical hardware virtualization.


LXC AND DOCKER :
---------------

Linux Containers (LXC) is an OS-level virtualization technology that enables you to create and run multiple Linux operating systems (OS) simultaneously on a single Linux machine (LXC host). LXC provides a set of tools to manage your container as well as templates to create a virtual environment of the most common Linux OS.

Docker is an open-source containerization technology that focuses on running a single application in an isolated environment. Its Docker Engine enables you to create, run, or distribute containers. You can also share applications and collaborate with other developers using Docker Hub.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`

Docker Daemon 
docker group   - /etc/group  = to add user , by default only root can run docker


[root@ip-172-31-1-219 ~]# docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
2db29710123e: Pull complete
Digest: sha256:faa03e786c97f07ef34423fccceeec2398ec8a5759259f94d99078f264e9d7af
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Installation:
=============
https://docs.docker.com/engine/install/

Docker Hub: https://hub.docker.com/

Docker Swarm : docker orchestration tool from docker , howwver we use k8
    1  yum install docker
    2  systemctl status docker
    3  systemctl start docker
    4  systemctl enable docker
    5  systemctl status docker
    
    

    8  docker ps  # gives list of container which are active
       docker ps -a # gives list of container which are in stopped state - total
       
    9  which docker
   10  cd container_id
   11  clear
   12  docker ps
   13  docker images
   
   
   14  docker pull centos # running as root user, to pull image from docker hub and pulls latest tags by default. can mention tags aswell
   15  docker images # gives list of images 
   16  docker ps # active state containers

   22  docker run centos  # running container having image centos
   23  docker ps
   24  docker ps -a
  
  
   25  docker run nginx  # this will automatically pulls image from hub and runs it
   
   26  docker pull loksaieta/loksaimvndevops:v1.0   # our own image
   27  docker images # gives list
   
   28  docker run -it loksaieta/loksaimvndevops bash
   
   
   29  docker --version
   30  docker run hello-world
 
   32  docker images
   33  docker ps
   34  docker ps -a
here
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Docker hub - registry for docker images

docker pull nginx:<tag_id>

    1  yum install docker
    2  systemctl status docker
    3  systemctl start docker
    4  systemctl enable docker
    5  systemctl status docker
    6  clear
    7  docket ps
    8  docker ps
    9  which docker
   10  cd container_id
   11  clear
   12  docker ps
   13  docker images
   14  docker pull centos
   15  docker images
   16  docker ps
   17  dockerclear
   18  clear
   19  docker inmages
   20  docker inmage
   21  docker images
   22  docker run centos
   23  docker ps
   24  docker ps -a
   25  docker run nginx
   26  docker pull loksaieta/loksaimvndevops:v1.0
   27  docker images
   28  docker run -it loksaieta/loksaimvndevops bash
   29  docker --version
   30  docker run hello-world
   31  clear
   32  docker images
   33  docker ps
   34  docker ps -a
   35  history
   36  docker pull nginx
   37  docker images
   38  docket rmi loksaieta/loksaimvndevops
   39  docker rmi loksaieta/loksaimvndevops
   40  docker ps -a
   41  docker rm a0303e44cb9e
   42  docker rmi loksaieta/loksaimvndevops
   43  docker images
   44  docker rmi loksaieta/loksaimvndevops
   45  docker ps -a
   46  docker rm
   47  docker rm b818a67fcc12
   48  docker ps -a
   49  docker iamges
   50  docker images
   51  docker rm nginx
   52  docker rmi nginx
   53  clear
   54  docker images
   55  docker pull nginx
   56  nginx -- version
   57  nginx --version
   58  docker run nginx
   59  docker images
   60  nginx --version
   61  docker run  --name myweb -p 7090:80 -d nginx   
   -- what above command does is : 
   > it will run container NGINX on port 80 (we need to know which service runs on which port , for Nginx it is 80)
   > consider nginx is runnning in private subnet , so do access this service from internet, we have to link internet -> public Ip host -> map to port 80 in private subnet.
   > here 7090 is the host ip (any port)
   > -d is detach , that means , when running this service , our terminal will not be freezed , that means we will have control on our terminal.
   > --name myweb is like giving name for this particular container process.
   > by defualt run command runs in foreground causing not to have access to terminal
      
      docker run --name myweb -d -P nginx  -> capital P is for automatically doing port mapping
      docker ps -a to see port
   
   62  docker ps
   63  docker stop 579d293a4641
       dockar start <image>
   64  docker ps -a
   65  history
   
   COntainers are stored in below path :
   /var/lib/docker/containers


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#Docker Installation | Configuration | Commands & Concepts:


image = class

containers  = objects to call class(image)
dependencies and all will be there in containers
Registry - place where you store docker images
you can host your own registry / docker hub

sudo yum install docker


yum install docker -y
docker version
systemctl status docker
systemctl start docker
systemctl status docker
systemctl enable docker





#Basic Docker Commands :

#goto : https://hub.docker.com/

#Test Docker with basic hello-world image from docker hub.


 # by default lates tag will be pulled if not you can mention the required tag to download
docker pull centos 

docker run centos 

docker run centos
docker run nginx

docker pull hello-world
docker pull docker/whalesay


docker images

docker run centos

docker ps     --> this is used to get running containers
docker ps -a    --> this is used to get list of containes - running/stopped/exited etc...

### Run Container in Interactive Mode:
###docker run -it --name=testvol1 centos bash
docker run -it centos bash

i -> interactive mode
t -> in termainal

docker run -it <images> bash

root@a0303e44cb9e:/usr/local/tomcat#

root@<container_id): interactive mode


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
docker pull loksaieta/loksaimvndevops:v1.0

cat /etc/*release*

### Print the Docker Centos Image Release Info.
dockerpath# cat /etc/*release*
dockerpath# exit

###Run Docker Container in DETACHED MODE : we can gain access to terminal
docker run -d centos sleep 20 
docker ps -a

###Run Docker Container in FOREGROUND MODE :
docker run centos sleep 20
docker ps -a

docker run -d centos sleep 200
docker stop <container_id>

docker rm 2c5b 1b4f

docker images
docker rmi <image_id>

### Before deleting image, ensure that it is not referenced to any container. 
### In it is mapped, delete the container first, then can re container image.

docker rmi -f hello-world

docker pull centos:centos7.9.2009

docker run centos sleep 1100

docker stop <container_id>
docker rm <contained_ip>

docket rmi <imaged_id>  - to remove the image from local machine

### Detached Mode
docker run -d centos sleep 2000

docker attach <running_container_id>  -- to attach , default
docker stop <container_id>

###docker pull timer

#docker pull jenkins

#docker run jenkins

docker inspect <container_id>   -- to get details of containers

docker history <imagename>

docker run tomcat 

### Port-Mapping / Port-Binding

goto hub.docker & search for tomcat

docker run -it -p 8088:8080 tomcat:8.0

#### -p host_port:container_port

Once you install tomcat on ur vm :

<public_ip>:8088


###Docker Logs
~~~~~~~~~~~~~~~~~~~~~~~

docker logs <container_id>

#Access Docker contents using 

- Non-Interactive Mode: 

docker exec <container_id/container_name> <any bash command>

docker exec myweb ls / 

bin
boot
dev
docker-entrypoint.d
docker-entrypoint.sh
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var


>  see we have our own container directory structure

docker exec < container_id> <bash_command>

docker exec e8553a4721d5 cat /etc/hosts

#Login to Docker Container using exec in Interactive Mode: (Using Container Name) 

docker exec -it <container_name-gallant_blackburn> bash

#Run Docker Image in Interactive Mode: (Using Image Name) 

docker run -it centos bash
dockerpath# cat /etc/*release*
dockerpath# exit

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
to get into containers and execute some command to do some changes (not recommended)

we do :

docker exec -it <container_id/container_name> /bin/bash

> what we are doing here is
i -> interactive
t -> terminal

so we are allowing bash script to execute in specified container
> we can install , run do whatever we want inside the container

exit
> it will throws us out from containers and we will return back to host machine

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DOCKER LOGS
------------
ALways run inspect command first to know , how containers installation happens and condition it checks!
 
 docker inspect <image_id>
 docker inspect 76c69feac34e

  141  docker run --name Mysql -d -P mysql:5.7.40   -> this will run and intall mysql:5.7.40
  142  docker ps   -> will give list of running process
  143  docker ps -a  -> all process list
  144  docker images -> will give list of images installed
  145  docker logs Mysql -> this will give logs about Mysql process
  146  docker run --name Mysql1 -d -P -e MYSQL_ROOT_PASSWORD=mypass mysql:5.7.40  -> -e is for providing export variables
  147  docker ps
  148  docker logs Mysql1
  149  history
  
  
  =====================================================================
  ###Docker Logs

docker logs <container_id>

#Access Docker contents using exec - Non-Interactive Mode: 

docker exec e8553a4721d5 cat /etc/hosts

#Login to Docker Container using exec in Interactive Mode: (Using Container Name) 

docker exec -it <container_name-gallant_blackburn> bash

#Run Docker Image in Interactive Mode: (Using Image Name) 

docker run -it centos bash
dockerpath# cat /etc/*release*
dockerpath# exit

  
  
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DOCKER VOLUMES
---------------

> Persistant storage for volatile containers

Bind:
-----

docker run --name db2 -d -e MYSQL_ROOT_PASSWORD=passwd -p 3030:3306 -v /root/vproddata:/var/lib/mysql mysql 

> we are attaching prodata directory from host sysem to containers directory

Mounting volume:
----------------

> Though both methods are similar, there is a slight difference. Docker manages Volumes and is usually not affected by other processes running on the same host. In contrast, Bind Mounts are just directories on the host file system and may be modified by other processes other than docker.

> Binding host volume to container

>>>   docker run -it --mount source=<volume_name>,destination=</container_volume_path> <image>

docker volumes:
---------------


> Stateless application
> statefull application

> image --> appl .war  = spl-db - credentials /config parameter
   * so secrets from host will be send to containers to access db


docker volume

docker volume create <volume_name>
docker volume ls

docker volume inspect <volume_name>  --- to check the mount point of volume

docker run --name proddb_volume -d -e MYSQL_ROOT_PASSWORD=passwd =p 3031:3306 -v <volume_name_created>:/var/lib/mysql <image_name/mysql>

docker run --name proddb_volume -d -e MYSQL_ROOT_PASSWORD=passwd -p  3031:3306 -v mydbdata:/var/lib/mysql mysql 

volume directory in host :

cd /var/lib/docker/volumes/mydbdata/_data -> this will create data from containers to host machine

> we can re- attach it to other containers aswll in docker volume

 "HostConfig": {
            "Binds": [ 
                "mydbdata:/var/lib/mysql"    --> gives bind info


"NetworkMode": "default",
            "PortBindings": {
                "3306/tcp": [
                    {
                        "HostIp": "",
                        "HostPort": "3031"    -> gives port info





